#if !ODIN_INSPECTOR
namespace Sirenix.OdinInspector
{

#pragma warning disable
using System;using System.Linq;using UnityEngine;using System.Collections.Generic;using Sirenix.OdinInspector.Internal;
// AssetListAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class AssetListAttribute : Attribute { public bool AutoPopulate; public string Tags; public string LayerNames; public string AssetNamePrefix; public string Path; public string CustomFilterMethod; public AssetListAttribute() { this.AutoPopulate = false; this.Tags = null; this.LayerNames = null; this.AssetNamePrefix = null; this.CustomFilterMethod = null; } } 
// AssetSelectorAttribute.cs
[System.Diagnostics.Conditional("UNITY_EDITOR")] public class AssetSelectorAttribute : Attribute { public bool IsUniqueList = true; public bool DrawDropdownForListElements = true; public bool DisableListAddButtonBehaviour; public bool ExcludeExistingValuesInList; public bool ExpandAllMenuItems = true; public bool FlattenTreeView; public int DropdownWidth; public int DropdownHeight; public string DropdownTitle; public string[] SearchInFolders; public string Filter; public string Paths { set { this.SearchInFolders = value.Split('|') .Select(x => x.Trim().Trim('/', '\\')) .ToArray(); } get { return this.SearchInFolders == null ? null : string.Join(",", this.SearchInFolders); } } } 
// AssetsOnlyAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class AssetsOnlyAttribute : Attribute { } 
// BoxGroupAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class BoxGroupAttribute : PropertyGroupAttribute { public bool ShowLabel; public bool CenterLabel; public BoxGroupAttribute(string group, bool showLabel = true, bool centerLabel = false, int order = 0) : base(group, order) { this.ShowLabel = showLabel; this.CenterLabel = centerLabel; } public BoxGroupAttribute() : this("_DefaultBoxGroup", false) { } protected override void CombineValuesWith(PropertyGroupAttribute other) { var attr = other as BoxGroupAttribute; if (this.ShowLabel == false || attr.ShowLabel == false) { this.ShowLabel = false; attr.ShowLabel = false; } this.CenterLabel |= attr.CenterLabel; } } 
// ButtonAttribute.cs
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class ButtonAttribute : ShowInInspectorAttribute { public int ButtonHeight; public string Name; public ButtonStyle Style; public bool Expanded; public bool DrawResult { set { this.drawResult = value; this.drawResultIsSet = true; } get { return this.drawResult; } } public bool DrawResultIsSet { get { return this.drawResultIsSet; } } private bool drawResult; private bool drawResultIsSet; public ButtonAttribute() { this.Name = null; this.ButtonHeight = (int)ButtonSizes.Small; } public ButtonAttribute(ButtonSizes size) { this.Name = null; this.ButtonHeight = (int)size; } public ButtonAttribute(int buttonSize) { this.ButtonHeight = buttonSize; this.Name = null; } public ButtonAttribute(string name) { this.Name = name; this.ButtonHeight = (int)ButtonSizes.Small; } public ButtonAttribute(string name, ButtonSizes buttonSize) { this.Name = name; this.ButtonHeight = (int)buttonSize; } public ButtonAttribute(string name, int buttonSize) { this.Name = name; this.ButtonHeight = buttonSize; } public ButtonAttribute(ButtonStyle parameterBtnStyle) { this.Name = null; this.ButtonHeight = (int)ButtonSizes.Small; this.Style = parameterBtnStyle; } public ButtonAttribute(int buttonSize, ButtonStyle parameterBtnStyle) { this.ButtonHeight = buttonSize; this.Name = null; this.Style = parameterBtnStyle; } public ButtonAttribute(ButtonSizes size, ButtonStyle parameterBtnStyle) { this.ButtonHeight = (int)size; this.Name = null; this.Style = parameterBtnStyle; } public ButtonAttribute(string name, ButtonStyle parameterBtnStyle) { this.Name = name; this.ButtonHeight = (int)ButtonSizes.Small; this.Style = parameterBtnStyle; } public ButtonAttribute(string name, ButtonSizes buttonSize, ButtonStyle parameterBtnStyle) { this.Name = name; this.ButtonHeight = (int)buttonSize; this.Style = parameterBtnStyle; } public ButtonAttribute(string name, int buttonSize, ButtonStyle parameterBtnStyle) { this.Name = name; this.ButtonHeight = buttonSize; this.Style = parameterBtnStyle; } } 
// ButtonGroupAttribute.cs
[IncludeMyAttributes, ShowInInspector] [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class ButtonGroupAttribute : PropertyGroupAttribute { public ButtonGroupAttribute(string group = "_DefaultGroup", int order = 0) : base(group, order) { } } 
// ButtonStyle.cs
public enum ButtonStyle { CompactBox, FoldoutButton, Box, } 
// ChildGameObjectsOnlyAttribute.cs
[System.Diagnostics.Conditional("UNITY_EDITOR")] public class ChildGameObjectsOnlyAttribute : Attribute { public bool IncludeSelf = true; } 
// ColorPaletteAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class ColorPaletteAttribute : Attribute { public string PaletteName; public bool ShowAlpha; public ColorPaletteAttribute() { this.PaletteName = null; this.ShowAlpha = true; } public ColorPaletteAttribute(string paletteName) { this.PaletteName = paletteName; this.ShowAlpha = true; } } 
// CustomContextMenuAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class CustomContextMenuAttribute : Attribute { public string MenuItem; public string MethodName; public CustomContextMenuAttribute(string menuItem, string methodName) { this.MenuItem = menuItem; this.MethodName = methodName; } } 
// CustomValueDrawerAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class CustomValueDrawerAttribute : Attribute { public string MethodName; public CustomValueDrawerAttribute(string methodName) { this.MethodName = methodName; } } 
// DelayedPropertyAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class DelayedPropertyAttribute : Attribute { } 
// DetailedInfoBoxAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [DontApplyToListElements] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class DetailedInfoBoxAttribute : Attribute { public string Message; public string Details; public InfoMessageType InfoMessageType; public string VisibleIf; public DetailedInfoBoxAttribute(string message, string details, InfoMessageType infoMessageType = InfoMessageType.Info, string visibleIf = null) { this.Message = message; this.Details = details; this.InfoMessageType = infoMessageType; this.VisibleIf = visibleIf; } } 
// DictionaryDrawerSettings.cs
[System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class DictionaryDrawerSettings : Attribute { public string KeyLabel = "Key"; public string ValueLabel = "Value"; public DictionaryDisplayOptions DisplayMode; public bool IsReadOnly; } 
// DisableContextMenuAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class DisableContextMenuAttribute : Attribute { public bool DisableForMember; public bool DisableForCollectionElements; public DisableContextMenuAttribute(bool disableForMember = true, bool disableCollectionElements = false) { this.DisableForMember = disableForMember; this.DisableForCollectionElements = disableCollectionElements; } } 
// DisableIfAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class DisableIfAttribute : Attribute { public string MemberName; public object Value; public DisableIfAttribute(string memberName) { this.MemberName = memberName; } public DisableIfAttribute(string memberName, object optionalValue) { this.MemberName = memberName; this.Value = optionalValue; } } 
// DisableInEditorModeAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class DisableInEditorModeAttribute : Attribute { } 
// DisableInInlineEditorsAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class DisableInInlineEditorsAttribute : Attribute { } 
// DisableInNonPrefabsAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class DisableInNonPrefabsAttribute : Attribute { } 
// DisableInPlayModeAttribute.cs
[AttributeUsage(AttributeTargets.All)] [DontApplyToListElements] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class DisableInPlayModeAttribute : Attribute { } 
// DisableInPrefabAssetsAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class DisableInPrefabAssetsAttribute : Attribute { } 
// DisableInPrefabInstancesAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class DisableInPrefabInstancesAttribute : Attribute { } 
// DisableInPrefabsAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class DisableInPrefabsAttribute : Attribute { } 
// DisplayAsStringAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class DisplayAsStringAttribute : Attribute { public bool Overflow; public DisplayAsStringAttribute() { this.Overflow = true; } public DisplayAsStringAttribute(bool overflow) { this.Overflow = overflow; } } 
// DoNotDrawAsReferenceAttribute.cs
[System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class DoNotDrawAsReferenceAttribute : Attribute { } 
// DontApplyToListElementsAttribute.cs
[AttributeUsage(AttributeTargets.Class)] public sealed class DontApplyToListElementsAttribute : Attribute { } 
// DrawWithUnityAttribute.cs
[AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class DrawWithUnityAttribute : Attribute { } 
// EnableForPrefabOnlyAttribute.cs
[Obsolete("Use DisableInPrefabInstance or DisableInPrefabAsset instead.", false)] [AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class EnableForPrefabOnlyAttribute : Attribute { } 
// EnableGUIAttribute.cs
[AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class EnableGUIAttribute : Attribute { } 
// EnableIfAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class EnableIfAttribute : Attribute { public string MemberName; public object Value; public EnableIfAttribute(string memberName) { this.MemberName = memberName; } public EnableIfAttribute(string memberName, object optionalValue) { this.MemberName = memberName; this.Value = optionalValue; } } 
// EnumPagingAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class EnumPagingAttribute : Attribute { } 
// EnumToggleButtonsAttribute.cs
[System.Diagnostics.Conditional("UNITY_EDITOR")] public class EnumToggleButtonsAttribute : Attribute { public EnumToggleButtonsAttribute() { } } 
// FilePathAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class FilePathAttribute : Attribute { public bool AbsolutePath; public string Extensions; public string ParentFolder; [Obsolete("Use RequireExistingPath instead.")] public bool RequireValidPath; public bool RequireExistingPath; public bool UseBackslashes; [Obsolete("Add a ReadOnly attribute to the property instead.")] public bool ReadOnly { get; set; } } 
// FolderPathAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class FolderPathAttribute : Attribute { public bool AbsolutePath; public string ParentFolder; [Obsolete("Use RequireExistingPath instead.")] public bool RequireValidPath; public bool RequireExistingPath; public bool UseBackslashes; } 
// FoldoutGroupAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class FoldoutGroupAttribute : PropertyGroupAttribute { public bool Expanded; public FoldoutGroupAttribute(string groupName, int order = 0) : base(groupName, order) { } public FoldoutGroupAttribute(string groupName, bool expanded, int order = 0) : base(groupName, order) { this.Expanded = expanded; this.HasDefinedExpanded = true; } public bool HasDefinedExpanded { get; private set; } protected override void CombineValuesWith(PropertyGroupAttribute other) { var attr = other as FoldoutGroupAttribute; if (attr.HasDefinedExpanded) { this.HasDefinedExpanded = true; this.Expanded = attr.Expanded; } if (this.HasDefinedExpanded) { attr.HasDefinedExpanded = true; attr.Expanded = this.Expanded; } } } 
// GUIColorAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class GUIColorAttribute : Attribute { public Color Color; public string GetColor; public GUIColorAttribute(float r, float g, float b, float a = 1f) { this.Color = new Color(r, g, b, a); } public GUIColorAttribute(string getColor) { this.GetColor = getColor; } } 
// HideDuplicateReferenceBoxAttribute.cs
[System.Diagnostics.Conditional("UNITY_EDITOR")] public class HideDuplicateReferenceBoxAttribute : Attribute { } 
// HideIfAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [DontApplyToListElements] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class HideIfAttribute : Attribute { public string MemberName; public object Value; public bool Animate; public HideIfAttribute(string memberName, bool animate = true) { this.MemberName = memberName; this.Animate = animate; } public HideIfAttribute(string memberName, object optionalValue, bool animate = true) { this.MemberName = memberName; this.Value = optionalValue; this.Animate = animate; } } 
// HideIfGroupAttribute.cs
[System.Diagnostics.Conditional("UNITY_EDITOR")] public class HideIfGroupAttribute : PropertyGroupAttribute { private string memberName; public bool Animate; public object Value; public string MemberName { get { return string.IsNullOrEmpty(this.memberName) ? this.GroupName : this.memberName; } set { this.memberName = value; } } public HideIfGroupAttribute(string path, bool animate = true) : base(path) { this.Animate = animate; } public HideIfGroupAttribute(string path, object value, bool animate = true) : base(path) { this.Value = value; this.Animate = animate; } protected override void CombineValuesWith(PropertyGroupAttribute other) { var attr = other as HideIfGroupAttribute; if (string.IsNullOrEmpty(this.memberName) == false) { attr.memberName = this.memberName; } if (this.Animate == false) { attr.Animate = this.Animate; } if (this.Value != null) { attr.Value = this.Value; } } } 
// HideInEditorModeAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class HideInEditorModeAttribute : Attribute { } 
// HideInInlineEditorsAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class HideInInlineEditorsAttribute : Attribute { } 
// HideInNonPrefabsAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class HideInNonPrefabsAttribute : Attribute { } 
// HideInPlayModeAttribute.cs
[AttributeUsage(AttributeTargets.All)] [DontApplyToListElements] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class HideInPlayModeAttribute : Attribute { } 
// HideInPrefabAssetsAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class HideInPrefabAssetsAttribute : Attribute { } 
// HideInPrefabInstancesAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class HideInPrefabInstancesAttribute : Attribute { } 
// HideInPrefabsAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class HideInPrefabsAttribute : Attribute { } 
// HideInTablesAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class HideInTablesAttribute : Attribute { } 
// HideLabelAttribute.cs
[AttributeUsage(AttributeTargetFlags.Default)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class HideLabelAttribute : Attribute { } 
// HideMonoScriptAttribute.cs
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class HideMonoScriptAttribute : Attribute { } 
// HideNetworkBehaviourFieldsAttribute.cs
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class HideNetworkBehaviourFieldsAttribute : Attribute { } 
// HideReferenceObjectPickerAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class HideReferenceObjectPickerAttribute : Attribute { } 
// HorizontalGroupAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class HorizontalGroupAttribute : PropertyGroupAttribute { public float Width; public float MarginLeft; public float MarginRight; public float PaddingLeft; public float PaddingRight; public float MinWidth; public float MaxWidth; public string Title; public float LabelWidth; public HorizontalGroupAttribute(string group, float width = 0, int marginLeft = 0, int marginRight = 0, int order = 0) : base(group, order) { this.Width = width; this.MarginLeft = marginLeft; this.MarginRight = marginRight; } public HorizontalGroupAttribute(float width = 0, int marginLeft = 0, int marginRight = 0, int order = 0) : this("_DefaultHorizontalGroup", width, marginLeft, marginRight, order) { } protected override void CombineValuesWith(PropertyGroupAttribute other) { this.Title = this.Title ?? (other as HorizontalGroupAttribute).Title; this.LabelWidth = Math.Max(this.LabelWidth, (other as HorizontalGroupAttribute).LabelWidth); } } 
// IndentAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class IndentAttribute : Attribute { public int IndentLevel; public IndentAttribute(int indentLevel = 1) { this.IndentLevel = indentLevel; } } 
// InfoBoxAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class InfoBoxAttribute : Attribute { public string Message; public InfoMessageType InfoMessageType; public string VisibleIf; public bool GUIAlwaysEnabled; public InfoBoxAttribute(string message, InfoMessageType infoMessageType = InfoMessageType.Info, string visibleIfMemberName = null) { this.Message = message; this.InfoMessageType = infoMessageType; this.VisibleIf = visibleIfMemberName; } public InfoBoxAttribute(string message, string visibleIfMemberName) { this.Message = message; this.InfoMessageType = InfoMessageType.Info; this.VisibleIf = visibleIfMemberName; } } 
// InlineButtonAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class InlineButtonAttribute : Attribute { public InlineButtonAttribute(string memberMethod, string label = null) { this.MemberMethod = memberMethod; this.Label = label; } public string MemberMethod { get; private set; } public string Label { get; private set; } } 
// InlineEditorAttribute.cs
[AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class InlineEditorAttribute : Attribute { public bool Expanded; public bool DrawHeader; public bool DrawGUI; public bool DrawPreview; public float MaxHeight; public float PreviewWidth = 100; public float PreviewHeight = 35; public bool IncrementInlineEditorDrawerDepth = true; public InlineEditorObjectFieldModes ObjectFieldMode; public bool DisableGUIForVCSLockedAssets = true; public InlineEditorAttribute(InlineEditorModes inlineEditorMode = InlineEditorModes.GUIOnly, InlineEditorObjectFieldModes objectFieldMode = InlineEditorObjectFieldModes.Boxed) { this.ObjectFieldMode = objectFieldMode; switch (inlineEditorMode) { case InlineEditorModes.GUIOnly: this.DrawGUI = true; break; case InlineEditorModes.GUIAndHeader: this.DrawGUI = true; this.DrawHeader = true; break; case InlineEditorModes.GUIAndPreview: this.DrawGUI = true; this.DrawPreview = true; break; case InlineEditorModes.SmallPreview: this.Expanded = true; this.DrawPreview = true; break; case InlineEditorModes.LargePreview: this.Expanded = true; this.DrawPreview = true; this.PreviewHeight = 170; break; case InlineEditorModes.FullEditor: this.DrawGUI = true; this.DrawHeader = true; this.DrawPreview = true; break; default: throw new NotImplementedException(); } } public InlineEditorAttribute(InlineEditorObjectFieldModes objectFieldMode) : this(InlineEditorModes.GUIOnly, objectFieldMode) { } } 
// InlinePropertyAttribute.cs
[AttributeUsage(AttributeTargets.All, Inherited = false)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class InlinePropertyAttribute : Attribute { public int LabelWidth; } 
// LabelTextAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class LabelTextAttribute : Attribute { public string Text; public LabelTextAttribute(string text) { this.Text = text; } } 
// LabelWidthAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class LabelWidthAttribute : Attribute { public float Width; public LabelWidthAttribute(float width) { this.Width = width; } } 
// ListDrawerSettingsAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class ListDrawerSettingsAttribute : Attribute { public bool HideAddButton; public bool HideRemoveButton; public string ListElementLabelName; public string CustomAddFunction; public string CustomRemoveIndexFunction; public string CustomRemoveElementFunction; public string OnBeginListElementGUI; public string OnEndListElementGUI; public bool AlwaysAddDefaultValue; public bool AddCopiesLastElement = false; private string onTitleBarGUI = null; private int numberOfItemsPerPage; private bool paging; private bool draggable; private bool isReadOnly; private bool showItemCount; private bool pagingHasValue = false; private bool draggableHasValue = false; private bool isReadOnlyHasValue = false; private bool showItemCountHasValue = false; private bool expanded = false; private bool expandedHasValue = false; private bool numberOfItemsPerPageHasValue = false; private bool showIndexLabels = false; private bool showIndexLabelsHasValue = false; public bool ShowPaging { get { return this.paging; } set { this.paging = value; this.pagingHasValue = true; } } public bool DraggableItems { get { return this.draggable; } set { this.draggable = value; this.draggableHasValue = true; } } public int NumberOfItemsPerPage { get { return this.numberOfItemsPerPage; } set { this.numberOfItemsPerPage = value; this.numberOfItemsPerPageHasValue = true; } } public bool IsReadOnly { get { return this.isReadOnly; } set { this.isReadOnly = value; this.isReadOnlyHasValue = true; } } public bool ShowItemCount { get { return this.showItemCount; } set { this.showItemCount = value; this.showItemCountHasValue = true; } } public bool Expanded { get { return this.expanded; } set { this.expanded = value; this.expandedHasValue = true; } } public bool ShowIndexLabels { get { return this.showIndexLabels; } set { this.showIndexLabels = value; this.showIndexLabelsHasValue = true; } } public string OnTitleBarGUI { get { return this.onTitleBarGUI; } set { this.onTitleBarGUI = value; } } public bool PagingHasValue { get { return this.pagingHasValue; } } public bool ShowItemCountHasValue { get { return this.showItemCountHasValue; } } public bool NumberOfItemsPerPageHasValue { get { return this.numberOfItemsPerPageHasValue; } } public bool DraggableHasValue { get { return this.draggableHasValue; } } public bool IsReadOnlyHasValue { get { return this.isReadOnlyHasValue; } } public bool ExpandedHasValue { get { return this.expandedHasValue; } } public bool ShowIndexLabelsHasValue { get { return this.showIndexLabelsHasValue; } } } 
// MaxValueAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class MaxValueAttribute : Attribute { public double MaxValue; public string Expression; public MaxValueAttribute(double maxValue) { this.MaxValue = maxValue; } public MaxValueAttribute(string expression) { this.Expression = expression; } } 
// MinMaxSliderAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class MinMaxSliderAttribute : Attribute { public float MinValue; public float MaxValue; public string MinMember; public string MaxMember; public string MinMaxMember; public bool ShowFields; public MinMaxSliderAttribute(float minValue, float maxValue, bool showFields = false) { this.MinValue = minValue; this.MaxValue = maxValue; this.ShowFields = showFields; } public MinMaxSliderAttribute(string minMember, float maxValue, bool showFields = false) { this.MinMember = minMember; this.MaxValue = maxValue; this.ShowFields = showFields; } public MinMaxSliderAttribute(float minValue, string maxMember, bool showFields = false) { this.MinValue = minValue; this.MaxMember = maxMember; this.ShowFields = showFields; } public MinMaxSliderAttribute(string minMember, string maxMember, bool showFields = false) { this.MinMember = minMember; this.MaxMember = maxMember; this.ShowFields = showFields; } public MinMaxSliderAttribute(string minMaxMember, bool showFields = false) { this.MinMaxMember = minMaxMember; this.ShowFields = showFields; } } 
// MinValueAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class MinValueAttribute : Attribute { public double MinValue; public string Expression; public MinValueAttribute(double minValue) { this.MinValue = minValue; } public MinValueAttribute(string expression) { this.Expression = expression; } } 
// MultiLinePropertyAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class MultiLinePropertyAttribute : Attribute { public int Lines; public MultiLinePropertyAttribute(int lines = 3) { this.Lines = Math.Max(1, lines); } } 
// OnInspectorGUIAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class OnInspectorGUIAttribute : ShowInInspectorAttribute { public string PrependMethodName; public string AppendMethodName; public OnInspectorGUIAttribute() { } public OnInspectorGUIAttribute(string methodName, bool append = true) { if (append) { this.AppendMethodName = methodName; } else { this.PrependMethodName = methodName; } } public OnInspectorGUIAttribute(string prependMethodName, string appendMethodName) { this.PrependMethodName = prependMethodName; this.AppendMethodName = appendMethodName; } } 
// OnValueChangedAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class OnValueChangedAttribute : Attribute { public string MethodName; public bool IncludeChildren; public OnValueChangedAttribute(string methodName, bool includeChildren = false) { this.MethodName = methodName; this.IncludeChildren = includeChildren; } } 
// PreviewFieldAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class PreviewFieldAttribute : Attribute { public float Height; public ObjectFieldAlignment Alignment; public bool AlignmentHasValue; public PreviewFieldAttribute() { this.Height = 0; } public PreviewFieldAttribute(float height) { this.Height = height; } public PreviewFieldAttribute(float height, ObjectFieldAlignment alignment) { this.Height = height; this.Alignment = alignment; this.AlignmentHasValue = true; } public PreviewFieldAttribute(ObjectFieldAlignment alignment) { this.Alignment = alignment; this.AlignmentHasValue = true; } } 
// ProgressBarAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class ProgressBarAttribute : Attribute { public double Min; public double Max; public string MinMember; public string MaxMember; public float R; public float G; public float B; public int Height; public string ColorMember; public string BackgroundColorMember; public bool Segmented; public string CustomValueStringMember; private bool drawValueLabel; private TextAlignment valueLabelAlignment; public ProgressBarAttribute(double min, double max, float r = 0.15f, float g = 0.47f, float b = 0.74f) { this.Min = min; this.Max = max; this.R = r; this.G = g; this.B = b; this.Height = 12; this.Segmented = false; this.drawValueLabel = true; this.DrawValueLabelHasValue = false; this.valueLabelAlignment = TextAlignment.Center; this.ValueLabelAlignmentHasValue = false; } public ProgressBarAttribute(string minMember, double max, float r = 0.15f, float g = 0.47f, float b = 0.74f) { this.MinMember = minMember; this.Max = max; this.R = r; this.G = g; this.B = b; this.Height = 12; this.Segmented = false; this.drawValueLabel = true; this.DrawValueLabelHasValue = false; this.valueLabelAlignment = TextAlignment.Center; this.ValueLabelAlignmentHasValue = false; } public ProgressBarAttribute(double min, string maxMember, float r = 0.15f, float g = 0.47f, float b = 0.74f) { this.Min = min; this.MaxMember = maxMember; this.R = r; this.G = g; this.B = b; this.Height = 12; this.Segmented = false; this.drawValueLabel = true; this.DrawValueLabelHasValue = false; this.valueLabelAlignment = TextAlignment.Center; this.ValueLabelAlignmentHasValue = false; } public ProgressBarAttribute(string minMember, string maxMember, float r = 0.15f, float g = 0.47f, float b = 0.74f) { this.MinMember = minMember; this.MaxMember = maxMember; this.R = r; this.G = g; this.B = b; this.Height = 12; this.Segmented = false; this.drawValueLabel = true; this.DrawValueLabelHasValue = false; this.valueLabelAlignment = TextAlignment.Center; this.ValueLabelAlignmentHasValue = false; } public bool DrawValueLabel { get { return this.drawValueLabel; } set { this.drawValueLabel = value; this.DrawValueLabelHasValue = true; } } public bool DrawValueLabelHasValue { get; private set; } public TextAlignment ValueLabelAlignment { get { return this.valueLabelAlignment; } set { this.valueLabelAlignment = value; this.ValueLabelAlignmentHasValue = true; } } public bool ValueLabelAlignmentHasValue { get; private set; } } 
// PropertyGroupAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public abstract class PropertyGroupAttribute : Attribute { public string GroupID; public string GroupName; public int Order; public PropertyGroupAttribute(string groupId, int order) { this.GroupID = groupId; this.Order = order; var index = groupId.LastIndexOf('/'); this.GroupName = index >= 0 && index < groupId.Length ? groupId.Substring(index + 1) : groupId; } public PropertyGroupAttribute(string groupId) : this(groupId, 0) { } public PropertyGroupAttribute Combine(PropertyGroupAttribute other) { if (other == null) { throw new ArgumentNullException("other"); } if (other.GetType() != this.GetType()) { throw new ArgumentException("Attributes to combine are not of the same type."); } if (other.GroupID != this.GroupID) { throw new ArgumentException("PropertyGroupAttributes to combine must have the same group id."); } if (this.Order == 0) { this.Order = other.Order; } else if (other.Order != 0) { this.Order = Math.Min(this.Order, other.Order); } this.CombineValuesWith(other); return this; } protected virtual void CombineValuesWith(PropertyGroupAttribute other) { } } 
// PropertyOrderAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class PropertyOrderAttribute : Attribute { public int Order; public PropertyOrderAttribute() { } public PropertyOrderAttribute(int order) { this.Order = order; } } 
// PropertyRangeAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class PropertyRangeAttribute : Attribute { public double Min; public double Max; public string MinMember; public string MaxMember; public PropertyRangeAttribute(double min, double max) { this.Min = min < max ? min : max; this.Max = max > min ? max : min; } public PropertyRangeAttribute(string minMember, double max) { this.MinMember = minMember; this.Max = max; } public PropertyRangeAttribute(double min, string maxMember) { this.Min = min; this.MaxMember = maxMember; } public PropertyRangeAttribute(string minMember, string maxMember) { this.MinMember = minMember; this.MaxMember = maxMember; } } 
// PropertySpaceAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true), DontApplyToListElements] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class PropertySpaceAttribute : Attribute { public float SpaceBefore; public float SpaceAfter; public PropertySpaceAttribute() { this.SpaceBefore = 8f; this.SpaceAfter = 0f; } public PropertySpaceAttribute(float spaceBefore) { this.SpaceBefore = spaceBefore; this.SpaceAfter = 0f; } public PropertySpaceAttribute(float spaceBefore, float spaceAfter) { this.SpaceBefore = spaceBefore; this.SpaceAfter = spaceAfter; } } 
// PropertyTooltipAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class PropertyTooltipAttribute : Attribute { public string Tooltip; public PropertyTooltipAttribute(string tooltip) { this.Tooltip = tooltip; } } 
// ReadOnlyAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class ReadOnlyAttribute : Attribute { } 
// RequiredAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class RequiredAttribute : Attribute { public string ErrorMessage; public InfoMessageType MessageType; public RequiredAttribute() { this.MessageType = InfoMessageType.Error; } public RequiredAttribute(string errorMessage, InfoMessageType messageType) { this.ErrorMessage = errorMessage; this.MessageType = messageType; } public RequiredAttribute(string errorMessage) { this.ErrorMessage = errorMessage; this.MessageType = InfoMessageType.Error; } public RequiredAttribute(InfoMessageType messageType) { this.MessageType = messageType; } } 
// ResponsiveButtonGroupAttribute.cs
[IncludeMyAttributes, ShowInInspector] [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class ResponsiveButtonGroupAttribute : PropertyGroupAttribute { public ButtonSizes DefaultButtonSize = ButtonSizes.Medium; public bool UniformLayout = false; public ResponsiveButtonGroupAttribute(string group = "_DefaultResponsiveButtonGroup") : base(group) { } protected override void CombineValuesWith(PropertyGroupAttribute other) { var otherAttr = other as ResponsiveButtonGroupAttribute; if (other == null) { return; } if (otherAttr.DefaultButtonSize != ButtonSizes.Medium) { this.DefaultButtonSize = otherAttr.DefaultButtonSize; } else if (this.DefaultButtonSize != ButtonSizes.Medium) { otherAttr.DefaultButtonSize = this.DefaultButtonSize; } this.UniformLayout = this.UniformLayout || otherAttr.UniformLayout; } } 
// SceneObjectsOnlyAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class SceneObjectsOnlyAttribute : Attribute { } 
// ShowDrawerChainAttribute.cs
[AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class ShowDrawerChainAttribute : Attribute { } 
// ShowForPrefabOnlyAttribute.cs
[Obsolete("Use HideInPrefabInstance or HideInPrefabAsset instead.", false)] [AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class ShowForPrefabOnlyAttribute : Attribute { } 
// ShowIfAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class ShowIfAttribute : Attribute { public string MemberName; public bool Animate; public object Value; public ShowIfAttribute(string memberName, bool animate = true) { this.MemberName = memberName; this.Animate = animate; } public ShowIfAttribute(string memberName, object optionalValue, bool animate = true) { this.MemberName = memberName; this.Value = optionalValue; this.Animate = animate; } } 
// ShowIfGroupAttribute.cs
[System.Diagnostics.Conditional("UNITY_EDITOR")] public class ShowIfGroupAttribute : PropertyGroupAttribute { private string memberName; public bool Animate; public object Value; public string MemberName { get { return string.IsNullOrEmpty(this.memberName) ? this.GroupName : this.memberName; } set { this.memberName = value; } } public ShowIfGroupAttribute(string path, bool animate = true) : base(path) { this.Animate = animate; } public ShowIfGroupAttribute(string path, object value, bool animate = true) : base(path) { this.Value = value; this.Animate = animate; } protected override void CombineValuesWith(PropertyGroupAttribute other) { var attr = other as ShowIfGroupAttribute; if (string.IsNullOrEmpty(this.memberName) == false) { attr.memberName = this.memberName; } if (this.Animate == false) { attr.Animate = this.Animate; } if (this.Value != null) { attr.Value = this.Value; } } } 
// ShowInInlineEditorsAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class ShowInInlineEditorsAttribute : Attribute { } 
// ShowInInspectorAttribute.cs
[JetBrains.Annotations.MeansImplicitUse] [AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = false)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class ShowInInspectorAttribute : Attribute { } 
// ShowOdinSerializedPropertiesInInspectorAttribute.cs
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class ShowOdinSerializedPropertiesInInspectorAttribute : Attribute { } 
// ShowPropertyResolverAttribute.cs
[System.Diagnostics.Conditional("UNITY_EDITOR")] public class ShowPropertyResolverAttribute : Attribute { } 
// SuffixLabelAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = false)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class SuffixLabelAttribute : Attribute { public string Label; public bool Overlay; public SuffixLabelAttribute(string label, bool overlay = false) { this.Label = label; this.Overlay = overlay; } } 
// SuppressInvalidAttributeErrorAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class SuppressInvalidAttributeErrorAttribute : Attribute { } 
// TabGroupAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class TabGroupAttribute : PropertyGroupAttribute, ISubGroupProviderAttribute { public const string DEFAULT_NAME = "_DefaultTabGroup"; public string TabName; public bool UseFixedHeight; public bool Paddingless; public bool HideTabGroupIfTabGroupOnlyHasOneTab; public TabGroupAttribute(string tab, bool useFixedHeight = false, int order = 0) : this(DEFAULT_NAME, tab, useFixedHeight, order) { } public TabGroupAttribute(string group, string tab, bool useFixedHeight = false, int order = 0) : base(group, order) { this.TabName = tab; this.UseFixedHeight = useFixedHeight; this.Tabs = new List<string>(); if (tab != null) { this.Tabs.Add(tab); } this.Tabs = new List<string>(this.Tabs); } public List<string> Tabs { get; private set; } protected override void CombineValuesWith(PropertyGroupAttribute other) { base.CombineValuesWith(other); var otherTab = other as TabGroupAttribute; if (otherTab.TabName != null) { this.UseFixedHeight = this.UseFixedHeight || otherTab.UseFixedHeight; this.Paddingless = this.Paddingless || otherTab.Paddingless; this.HideTabGroupIfTabGroupOnlyHasOneTab = this.HideTabGroupIfTabGroupOnlyHasOneTab || otherTab.HideTabGroupIfTabGroupOnlyHasOneTab; if (this.Tabs.Contains(otherTab.TabName) == false) { this.Tabs.Add(otherTab.TabName); } } } IList<PropertyGroupAttribute> ISubGroupProviderAttribute.GetSubGroupAttributes() { int count = 0; List<PropertyGroupAttribute> result = new List<PropertyGroupAttribute>(this.Tabs.Count); foreach (var tab in this.Tabs) { result.Add(new TabSubGroupAttribute(this.GroupID + "/" + tab, count++)); } return result; } string ISubGroupProviderAttribute.RepathMemberAttribute(PropertyGroupAttribute attr) { var tabAttr = (TabGroupAttribute)attr; return this.GroupID + "/" + tabAttr.TabName; } [System.Diagnostics.Conditional("UNITY_EDITOR")] private class TabSubGroupAttribute : PropertyGroupAttribute { public TabSubGroupAttribute(string groupId, int order) : base(groupId, order) { } } } 
// TableColumnWidthAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class TableColumnWidthAttribute : Attribute { public int Width; public bool Resizable = true; public TableColumnWidthAttribute(int width, bool resizable = true) { this.Width = width; this.Resizable = resizable; } } 
// TableListAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class TableListAttribute : Attribute { public int NumberOfItemsPerPage; public bool IsReadOnly; public int DefaultMinColumnWidth = 40; public bool ShowIndexLabels; public bool DrawScrollView = true; public int MinScrollViewHeight = 350; public int MaxScrollViewHeight; public bool AlwaysExpanded; public bool HideToolbar = false; public int CellPadding = 2; [SerializeField, HideInInspector] private bool showPagingHasValue = false; [SerializeField, HideInInspector] private bool showPaging = false; public bool ShowPaging { get { return this.showPaging; } set { this.showPaging = value; this.showPagingHasValue = true; } } public bool ShowPagingHasValue { get { return this.showPagingHasValue; } } public int ScrollViewHeight { get { return Math.Min(this.MinScrollViewHeight, this.MaxScrollViewHeight); } set { this.MinScrollViewHeight = this.MaxScrollViewHeight = value; } } } 
// TableMatrixAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class TableMatrixAttribute : Attribute { public bool IsReadOnly = false; public bool ResizableColumns = true; public string VerticalTitle = null; public string HorizontalTitle = null; public string DrawElementMethod = null; public int RowHeight = 0; public bool SquareCells = false; public bool HideColumnIndices = false; public bool HideRowIndices = false; public bool RespectIndentLevel = true; public bool Transpose = false; } 
// TitleAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class TitleAttribute : Attribute { public string Title; public string Subtitle; public bool Bold; public bool HorizontalLine; public TitleAlignments TitleAlignment; public TitleAttribute(string title, string subtitle = null, TitleAlignments titleAlignment = TitleAlignments.Left, bool horizontalLine = true, bool bold = true) { this.Title = title ?? "null"; this.Subtitle = subtitle; this.Bold = bold; this.TitleAlignment = titleAlignment; this.HorizontalLine = horizontalLine; } } 
// TitleGroupAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class TitleGroupAttribute : PropertyGroupAttribute { public string Subtitle; public TitleAlignments Alignment; public bool HorizontalLine; public bool BoldTitle; public bool Indent; public TitleGroupAttribute(string title, string subtitle = null, TitleAlignments alignment = TitleAlignments.Left, bool horizontalLine = true, bool boldTitle = true, bool indent = false, int order = 0) : base(title, order) { this.Subtitle = subtitle; this.Alignment = alignment; this.HorizontalLine = horizontalLine; this.BoldTitle = boldTitle; this.Indent = indent; } protected override void CombineValuesWith(PropertyGroupAttribute other) { var t = other as TitleGroupAttribute; if (this.Subtitle != null) { t.Subtitle = this.Subtitle; } else { this.Subtitle = t.Subtitle; } if (this.Alignment != TitleAlignments.Left) { t.Alignment = this.Alignment; } else { this.Alignment = t.Alignment; } if (this.HorizontalLine != true) { t.HorizontalLine = this.HorizontalLine; } else { this.HorizontalLine = t.HorizontalLine; } if (this.BoldTitle != true) { t.BoldTitle = this.BoldTitle; } else { this.BoldTitle = t.BoldTitle; } if (this.Indent == true) { t.Indent = this.Indent; } else { this.Indent = t.Indent; } } } 
// ToggleAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class ToggleAttribute : Attribute { public string ToggleMemberName; public bool CollapseOthersOnExpand; public ToggleAttribute(string toggleMemberName) { this.ToggleMemberName = toggleMemberName; this.CollapseOthersOnExpand = true; } } 
// ToggleGroupAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class ToggleGroupAttribute : PropertyGroupAttribute { public string ToggleGroupTitle; public bool CollapseOthersOnExpand; public ToggleGroupAttribute(string toggleMemberName, int order = 0, string groupTitle = null) : base(toggleMemberName, order) { this.ToggleGroupTitle = groupTitle; this.CollapseOthersOnExpand = true; } public ToggleGroupAttribute(string toggleMemberName, string groupTitle) : this(toggleMemberName, 0, groupTitle) { } [Obsolete("Use [ToggleGroup(\"toggleMemberName\", groupTitle: \"$titleStringMemberName\")] instead")] public ToggleGroupAttribute(string toggleMemberName, int order, string groupTitle, string titleStringMemberName) : base(toggleMemberName, order) { this.ToggleGroupTitle = groupTitle; this.CollapseOthersOnExpand = true; } public string ToggleMemberName { get { return this.GroupName; } } [Obsolete("Add a $ infront of group title instead, i.e: \"$MyStringMember\".")] public string TitleStringMemberName { get; set; } protected override void CombineValuesWith(PropertyGroupAttribute other) { var attr = other as ToggleGroupAttribute; if (this.ToggleGroupTitle == null) { this.ToggleGroupTitle = attr.ToggleGroupTitle; } else if (attr.ToggleGroupTitle == null) { attr.ToggleGroupTitle = this.ToggleGroupTitle; } this.CollapseOthersOnExpand = this.CollapseOthersOnExpand || attr.CollapseOthersOnExpand; attr.CollapseOthersOnExpand = this.CollapseOthersOnExpand; } } 
// ToggleLeftAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class ToggleLeftAttribute : Attribute { } 
// TypeFilterAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class TypeFilterAttribute : Attribute { public string MemberName; public string DropdownTitle; public TypeFilterAttribute(string memberName) { this.MemberName = memberName; } } 
// TypeInfoBoxAttribute.cs
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class TypeInfoBoxAttribute : Attribute { public string Message; public TypeInfoBoxAttribute(string message) { this.Message = message; } } 
// ValidateInputAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class ValidateInputAttribute : Attribute { public string DefaultMessage; public string MemberName; public InfoMessageType MessageType; public bool IncludeChildren; [Obsolete("Use the ContinuousValidationCheck member instead.")] public bool ContiniousValidationCheck { get { return this.ContinuousValidationCheck; } set { this.ContinuousValidationCheck = value; } } public bool ContinuousValidationCheck; public ValidateInputAttribute(string memberName, string defaultMessage = null, InfoMessageType messageType = InfoMessageType.Error) { this.MemberName = memberName; this.DefaultMessage = defaultMessage; this.MessageType = messageType; this.IncludeChildren = true; } [Obsolete("Rejecting invalid input is no longer supported. Use the other constructor instead.", false)] public ValidateInputAttribute(string memberName, string message, InfoMessageType messageType, bool rejectedInvalidInput) { this.MemberName = memberName; this.DefaultMessage = message; this.MessageType = messageType; this.IncludeChildren = true; } } 
// ValueDropdownAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class ValueDropdownAttribute : Attribute { public string MemberName; public int NumberOfItemsBeforeEnablingSearch; public bool IsUniqueList; public bool DrawDropdownForListElements; public bool DisableListAddButtonBehaviour; public bool ExcludeExistingValuesInList; public bool ExpandAllMenuItems; public bool AppendNextDrawer; public bool DisableGUIInAppendedDrawer; public bool DoubleClickToConfirm; public bool FlattenTreeView; public int DropdownWidth; public int DropdownHeight; public string DropdownTitle; public bool SortDropdownItems; public bool HideChildProperties = false; public ValueDropdownAttribute(string memberName) { this.NumberOfItemsBeforeEnablingSearch = 10; this.MemberName = memberName; this.DrawDropdownForListElements = true; } } public interface IValueDropdownItem { string GetText(); object GetValue(); } public class ValueDropdownList<T> : List<ValueDropdownItem<T>> { public void Add(string text, T value) { this.Add(new ValueDropdownItem<T>(text, value)); } public void Add(T value) { this.Add(new ValueDropdownItem<T>(value.ToString(), value)); } } public struct ValueDropdownItem : IValueDropdownItem { public string Text; public object Value; public ValueDropdownItem(string text, object value) { this.Text = text; this.Value = value; } public override string ToString() { return this.Text ?? (this.Value + ""); } string IValueDropdownItem.GetText() { return this.Text; } object IValueDropdownItem.GetValue() { return this.Value; } } public struct ValueDropdownItem<T> : IValueDropdownItem { public string Text; public T Value; public ValueDropdownItem(string text, T value) { this.Text = text; this.Value = value; } string IValueDropdownItem.GetText() { return this.Text; } object IValueDropdownItem.GetValue() { return this.Value; } public override string ToString() { return this.Text ?? (this.Value + ""); } } 
// VerticalGroupAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class VerticalGroupAttribute : PropertyGroupAttribute { public float PaddingTop; public float PaddingBottom; public VerticalGroupAttribute(string groupId, int order = 0) : base(groupId, order) { } public VerticalGroupAttribute(int order = 0) : this("_DefaultVerticalGroup", order) { } protected override void CombineValuesWith(PropertyGroupAttribute other) { var a = other as VerticalGroupAttribute; if (a != null) { if (a.PaddingTop != 0) { this.PaddingTop = a.PaddingTop; } if (a.PaddingBottom != 0) { this.PaddingBottom = a.PaddingBottom; } } } } 
// WrapAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public sealed class WrapAttribute : Attribute { public double Min; public double Max; public WrapAttribute(double min, double max) { this.Min = min < max ? min : max; this.Max = max > min ? max : min; } } 
// AttributeTargetFlags.cs
public static class AttributeTargetFlags { public const AttributeTargets Default = AttributeTargets.All; } 
// ButtonSizes.cs
public enum ButtonSizes { Small = 0, Medium = 22, Large = 31, Gigantic = 62, } 
// DictionaryDisplayOptions.cs
public enum DictionaryDisplayOptions { OneLine, Foldout, CollapsedFoldout, ExpandedFoldout } 
// IncludeMyAttributesAttribute.cs
[AttributeUsage(AttributeTargets.Class)] public class IncludeMyAttributesAttribute : Attribute { } 
// InfoMessageType.cs
public enum InfoMessageType { None, Info, Warning, Error } 
// InlineEditorModes.cs
public enum InlineEditorModes { GUIOnly = 0, GUIAndHeader = 1, GUIAndPreview = 2, SmallPreview = 3, LargePreview = 4, FullEditor = 5 } 
// InlineEditorObjectFieldModes.cs
public enum InlineEditorObjectFieldModes { Boxed, Foldout, Hidden, CompletelyHidden, } 
// ObjectFieldAlignment.cs
public enum ObjectFieldAlignment { Left = 0, Center = 1, Right = 2, } 
// OdinRegisterAttributeAttribute.cs
[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true, Inherited = true)] [System.Diagnostics.Conditional("UNITY_EDITOR")] public class OdinRegisterAttributeAttribute : Attribute { public Type AttributeType; public string Categories; public string Description; public string DocumentationUrl; public OdinRegisterAttributeAttribute(Type attributeType, string category, string description) { this.AttributeType = attributeType; this.Categories = category; this.Description = description; } public OdinRegisterAttributeAttribute(Type attributeType, string category, string description, string url) { this.AttributeType = attributeType; this.Categories = category; this.Description = description; this.DocumentationUrl = url; } } 
// TitleAlignments.cs
public enum TitleAlignments { Left, Centered, Right, Split, } 

}
namespace Sirenix.OdinInspector.Internal
{

#pragma warning disable
using System.Collections.Generic;
// ISubGroupProviderAttribute.cs
public interface ISubGroupProviderAttribute { IList<PropertyGroupAttribute> GetSubGroupAttributes(); string RepathMemberAttribute(PropertyGroupAttribute attr); } 

}
namespace Rhinox.GUIUtils.Odin
{
using System;using System.Diagnostics;using Sirenix.OdinInspector;using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Collections;using System.Collections.Generic;
#if ODIN_INSPECTOR
using Sirenix.OdinInspector;
#endif

// AnimationCurveHeightAttribute.cs
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = true)] [Conditional("UNITY_EDITOR")] public class AnimationCurveHeightAttribute : Attribute { public int height; public AnimationCurveHeightAttribute(int height = 20) { this.height = height; } } 
// AssignableTypeFilterAttribute.cs
[AttributeUsage(AttributeTargets.All)] [Conditional("UNITY_EDITOR")] public class AssignableTypeFilterAttribute : Attribute { public Type BaseType; public string DropdownTitle; public bool Expanded = false; public AssignableTypeFilterAttribute() { } public AssignableTypeFilterAttribute(Type baseType) { BaseType = baseType; } } 
// BoldLabelAttribute.cs
public class BoldLabelAttribute : Attribute { } 
// CombinedAttributes.cs
[IncludeMyAttributes] [ShowInInspector, HideInPlayMode] public class ShowInEditorAttribute : Attribute { } [IncludeMyAttributes] [ShowInInspector, HideInEditorMode] public class ShowInPlayModeAttribute : Attribute { } [IncludeMyAttributes] [ShowInInspector, ReadOnly] public class ShowReadOnlyAttribute : Attribute { } [IncludeMyAttributes] [ShowInInspector, ReadOnly, HideInPlayMode] public class ShowReadOnlyInEditorAttribute : Attribute { } [IncludeMyAttributes] [ShowInInspector, ReadOnly, HideInEditorMode] public class ShowReadOnlyInPlayModeAttribute : Attribute { } [IncludeMyAttributes] [HideLabel, HideReferenceObjectPicker, HideDuplicateReferenceBox] [Obsolete("Does not work - Code seems to check for HideReferenceObjectPicker directly before resolving this.")] public class HideReferencePickerCompletelyAttribute : Attribute { } 
// DrawAsUnityObjectAttribute.cs
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter)] [Conditional("UNITY_EDITOR")] public class DrawAsUnityObjectAttribute : Attribute { } 
// EditableLabelAttribute.cs
[AttributeUsage(AttributeTargets.All)] [Conditional("UNITY_EDITOR")] public class EditableLabelAttribute : Attribute { public string LabelProperty; public EditableLabelAttribute(string labelProp) { LabelProperty = labelProp; } } 
// FittedLabelAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [Conditional("UNITY_EDITOR")] public class FittedLabelAttribute : Attribute { public string Text; public FittedLabelAttribute() {} public FittedLabelAttribute(string text) { Text = text; } } 
// FoldoutContainerAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [Conditional("UNITY_EDITOR")] public class FoldoutContainerAttribute : PropertyGroupAttribute { public bool Expanded; public FoldoutContainerAttribute(string groupName, int order = 0) : base(groupName, order) { } public FoldoutContainerAttribute(string groupName, bool expanded, int order = 0) : base(groupName, order) { this.Expanded = expanded; this.HasDefinedExpanded = true; } public bool HasDefinedExpanded { get; private set; } protected override void CombineValuesWith(PropertyGroupAttribute other) { FoldoutContainerAttribute foldoutGroupAttribute = other as FoldoutContainerAttribute; if (foldoutGroupAttribute.HasDefinedExpanded) { this.HasDefinedExpanded = true; this.Expanded = foldoutGroupAttribute.Expanded; } if (!this.HasDefinedExpanded) return; foldoutGroupAttribute.HasDefinedExpanded = true; foldoutGroupAttribute.Expanded = this.Expanded; } } 
// GenericValueAttribute.cs
public class GenericValueAttribute : Attribute { public string TypeName { get; private set; } public Type TargetType { get; private set; } public GenericValueAttribute(Type type) { TargetType = type; } public GenericValueAttribute(string type) { TypeName = type; TargetType = null; } } 
// HideIfNullAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [IncludeMyAttributes] [DontApplyToListElements] [HideIf("@$property.ValueEntry.WeakSmartValue == null")] public class HideIfNullAttribute : Attribute { } 
// IconToggleAttribute.cs
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter)] [Conditional("UNITY_EDITOR")] public class IconToggleAttribute : Attribute { public string TrueIcon; public string FalseIcon; public IconToggleAttribute(string icon) { TrueIcon = icon; FalseIcon = icon; } public IconToggleAttribute(string trueIcon, string falseIcon) { TrueIcon = trueIcon; FalseIcon = falseIcon; } } 
// IgnoreInScriptableObjectCreatorAttribute.cs
[AttributeUsage(AttributeTargets.Class, Inherited = false)] [Conditional("UNITY_EDITOR")] public class IgnoreInScriptableObjectCreatorAttribute : Attribute {} 
// InlineEditorIconAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [Conditional("UNITY_EDITOR")] public class InlineEditorIconAttribute : Attribute { public string EditorIcon { get; private set; } public string MemberMethod { get; private set; } public string Tooltip { get; set; } public InlineEditorIconAttribute(string memberMethod, string editorIcon) { this.MemberMethod = memberMethod; this.EditorIcon = editorIcon; } } 
// InlineErrorAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [Conditional("UNITY_EDITOR")] public class InlineErrorAttribute : Attribute { public string Text { get; private set; } public string MemberName; public object Value; public InlineErrorAttribute(string text, string memberName) { this.Text = text; this.MemberName = memberName; } public InlineErrorAttribute(string text, string memberName, object optionalValue) { this.Text = text; this.MemberName = memberName; this.Value = optionalValue; } } 
// InlineIconButtonAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true)] [Conditional("UNITY_EDITOR")] public class InlineIconButtonAttribute : Attribute { public string Icon; public string MethodName; public string Tooltip; public bool ForceEnable; public InlineIconButtonAttribute(string icon, string methodName) { this.Icon = icon; this.MethodName = methodName; } } [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [Conditional("UNITY_EDITOR")] public class InlineListElementIconButtonAttribute : Attribute { public string Icon; public string MethodName; public string Tooltip; public bool ForceEnable; public InlineListElementIconButtonAttribute(string icon, string methodName) { this.Icon = icon; this.MethodName = methodName; } } 
// InlinePropertyAltAttribute.cs
[AttributeUsage(AttributeTargets.All, Inherited = false)] [Conditional("UNITY_EDITOR")] public class InlinePropertyAltAttribute : Attribute { } 
// InlineWarningAttribute.cs
[DontApplyToListElements] [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [Conditional("UNITY_EDITOR")] public class InlineWarningAttribute : Attribute { public string Text { get; private set; } public string MemberName; public object Value; public InlineWarningAttribute(string text, string memberName) { this.Text = text; this.MemberName = memberName; } public InlineWarningAttribute(string text, string memberName, object optionalValue) { this.Text = text; this.MemberName = memberName; this.Value = optionalValue; } } 
// LayerAttribute.cs
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter)] [Conditional("UNITY_EDITOR")] public class LayerAttribute : Attribute { } 
// ListItemSelectorAttribute.cs
[Conditional("UNITY_EDITOR")] public class ListItemSelectorAttribute : Attribute { public string SetSelectedMethod;
#if UNITY_EDITOR
public Color SelectedColor = EditorGUIUtility.isProSkin ? new Color (91, 91, 91, 255) : new Color (222, 222, 222, 255);
#else
public Color SelectedColor = Color.white;
#endif
public ListItemSelectorAttribute(string setSelectedMethod) { this.SetSelectedMethod = setSelectedMethod; } public ListItemSelectorAttribute(string setSelectedMethod, float r, float g, float b) : this(setSelectedMethod) { this.SelectedColor = new Color(r, g, b); } } 
// OptionalValueAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)] [Conditional("UNITY_EDITOR")] public sealed class OptionalValueAttribute : Attribute { public string Tooltip; public OptionalValueAttribute(string tooltip = null) { Tooltip = tooltip; } } 
// OrderRelativeToAttribute.cs
[AttributeUsage(AttributeTargets.Property, Inherited = true)] [Conditional("UNITY_EDITOR")] [DontApplyToListElements] public class OrderRelativeToAttribute : ShowInInspectorAttribute { public string Member; public int OrderAfterMember; public OrderRelativeToAttribute(string MemberName) { Member = MemberName; OrderAfterMember = 1; } public OrderRelativeToAttribute(string MemberName, int AdditionalOrder) { Member = MemberName;
#if UNITY_EDITOR
if (Mathf.Abs(AdditionalOrder) > 9) { UnityEngine.Debug.LogWarning("Max Additional Order for attributes is 9."); AdditionalOrder = 9 * (int) Mathf.Sign(AdditionalOrder); }
#endif
OrderAfterMember = AdditionalOrder; } } [Conditional("UNITY_EDITOR")] public class OrderBeforeAttribute : OrderRelativeToAttribute { public OrderBeforeAttribute(string MemberName) : base(MemberName, -1) { } } [Conditional("UNITY_EDITOR")] public class OrderAfterAttribute : OrderRelativeToAttribute { public OrderAfterAttribute(string MemberName) : base(MemberName, 1) { } } 
// OverrideGroupAttribute.cs
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = true, Inherited = true)] [Conditional("UNITY_EDITOR")] public class OverrideGroupAttribute : PropertyGroupAttribute { public string ToggleMemberName; public string HideIfMemberName; public OverrideGroupAttribute(string toggleMemberName, string groupId, int order, string hideIfMemberName = null) : base(groupId, order) { ToggleMemberName = toggleMemberName; HideIfMemberName = hideIfMemberName; } public OverrideGroupAttribute(string toggleMemberName, string groupId, string hideIfMemberName = null) : base(groupId) { ToggleMemberName = toggleMemberName; HideIfMemberName = hideIfMemberName; } public OverrideGroupAttribute(string toggleMemberName, string hideIfMemberName = null) : base(toggleMemberName) { ToggleMemberName = toggleMemberName; HideIfMemberName = hideIfMemberName; } protected override void CombineValuesWith(PropertyGroupAttribute other) { OverrideGroupAttribute otherGroupAttribute = other as OverrideGroupAttribute; if (ToggleMemberName == null) ToggleMemberName = otherGroupAttribute.ToggleMemberName; else if (otherGroupAttribute.ToggleMemberName == null) otherGroupAttribute.ToggleMemberName = this.ToggleMemberName; if (HideIfMemberName == null) HideIfMemberName = otherGroupAttribute.HideIfMemberName; else if (otherGroupAttribute.HideIfMemberName == null) otherGroupAttribute.HideIfMemberName = this.HideIfMemberName; } } 
// PageSliderAttribute.cs
[AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)] [Conditional("UNITY_EDITOR"), DontApplyToListElements] public class PageSliderAttribute : Attribute { } 
// PropertiesGroupAttribute.cs
public class PropertiesGroupAttribute : PropertyGroupAttribute { public string RootPropertyName; public bool HideWhenDefault; public PropertiesGroupAttribute(string rootPropertyName, bool hideWhenDefault = true) : base(rootPropertyName) { RootPropertyName = rootPropertyName; HideWhenDefault = hideWhenDefault; } } 
// ProtectedEditableAttribute.cs
public class ProtectedEditableAttribute : Attribute { public string Message; } 
// SearchPropertyAttribute.cs
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter)] [Conditional("UNITY_EDITOR")] public class SearchPropertyAttribute : Attribute { } 
// ShaderParameterSelectorAttribute.cs
public enum ShaderParameterType { None, Float, Color, Vector, Texture } [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter)] [Conditional("UNITY_EDITOR")] public class ShaderParameterSelectorAttribute : Attribute { public string ShaderProperty; public string TypeProperty; public ShaderParameterSelectorAttribute(string shaderProperty, string typeProperty = null) { ShaderProperty = shaderProperty; TypeProperty = typeProperty; } } 
// TagSelectorAttribute.cs
[AttributeUsage(AttributeTargets.All)] [Conditional("UNITY_EDITOR")] public class TagSelectorAttribute : Attribute { } 
// ToggleButtonAttribute.cs
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter)] [Conditional("UNITY_EDITOR")] public class ToggleButtonAttribute : PropertyGroupAttribute { public ToggleButtonAttribute() : base("DefaultToggleButtons") {} public ToggleButtonAttribute(string groupId) : base(groupId) { } } 
// ToggleButtonOppositeAttribute.cs
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter)] [Conditional("UNITY_EDITOR")] public class ToggleButtonOppositeAttribute : Attribute { public string OppositeName; public ToggleButtonOppositeAttribute(string oppositeName) { OppositeName = oppositeName; } } 
// ToggledByAttribute.cs
public class ToggledByAttribute : Attribute { public string ToggleMember; public bool MakeReadOnly = true; public ToggledByAttribute(string member) { ToggleMember = member; } } 
// UnfoldListAttribute.cs
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property | AttributeTargets.Parameter)] [Conditional("UNITY_EDITOR")]
#if ODIN_INSPECTOR
[DontApplyToListElements]
#endif
public class UnfoldListAttribute : Attribute { public TextAlignment LabelAlignment; public string OnBeforeTitleGUI; public string OnAfterTitleGUI; public UnfoldListAttribute(TextAlignment labelAlignment = TextAlignment.Right) { LabelAlignment = labelAlignment; } } 

}

#endif